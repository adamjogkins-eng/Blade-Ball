<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Blade Ball - Cyber Tokyo</title>
    <style>
        :root {
            --neon-pink: #ff00ff;
            --neon-blue: #00ffff;
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #010105; 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }
        
        /* Fixed UI Layering */
        #lobby, #overlay {
            position: absolute;
            inset: 0;
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            background: radial-gradient(circle at center, #0a0a25 0%, #02020a 100%);
        }

        .lobby-title {
            font-size: clamp(40px, 12vw, 80px);
            font-weight: 950;
            color: #fff;
            text-shadow: 0 0 10px var(--neon-pink), 0 0 30px var(--neon-blue);
            margin: 0;
            font-style: italic;
            text-transform: uppercase;
        }

        .player-select {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 30px 0;
            padding: 0 20px;
        }

        .btn-count {
            width: 50px;
            height: 50px;
            border: 2px solid rgba(0, 255, 255, 0.2);
            background: rgba(0, 255, 255, 0.05);
            color: var(--neon-blue);
            border-radius: 8px;
            font-weight: 800;
            font-size: 18px;
            cursor: pointer;
        }

        .btn-count.active {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 15px var(--neon-blue);
            border-color: #fff;
        }

        #start-game-btn {
            padding: 18px 60px;
            background: var(--neon-pink);
            border: none;
            color: white;
            font-weight: 900;
            font-size: 22px;
            clip-path: polygon(10% 0, 100% 0, 90% 100%, 0 100%);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
        }

        /* In-Game UI */
        #game-ui {
            position: absolute;
            top: 40px;
            width: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            z-index: 100;
        }

        #status {
            color: #fff;
            font-size: 20px;
            font-weight: 900;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--neon-blue);
            margin-bottom: 10px;
        }

        #indicator { width: 240px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
        #parry-bar { width: 100%; height: 100%; background: var(--neon-pink); transition: width 0.1s linear; }
        #parry-bar.resetting { background: #fff; transition: none; }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 50px;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 150;
        }

        #joystick-wrapper {
            width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        #joystick-stick {
            width: 60px; height: 60px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #fff;
        }

        #parry-btn {
            width: 120px; height: 120px;
            background: rgba(255, 0, 255, 0.2);
            border: 3px solid var(--neon-pink);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 900;
            font-size: 22px;
            text-shadow: 0 0 10px #fff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
            user-select: none;
        }

        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>

    <div id="lobby">
        <h1 class="lobby-title">Blade Ball</h1>
        <p style="letter-spacing: 5px; color: var(--neon-blue); font-size: 12px;">CYBERPUNK ARENA</p>
        <div class="player-select">
            <button class="btn-count" data-count="1">1</button>
            <button class="btn-count" data-count="2">2</button>
            <button class="btn-count" data-count="3">3</button>
            <button class="btn-count" data-count="4">4</button>
            <button class="btn-count" data-count="5">5</button>
            <button class="btn-count" data-count="6">6</button>
            <button class="btn-count" data-count="7">7</button>
            <button class="btn-count active" data-count="8">8</button>
        </div>
        <button id="start-game-btn">ENTER ARENA</button>
    </div>

    <div id="game-ui">
        <h2 id="status">INITIATING...</h2>
        <div id="indicator"><div id="parry-bar"></div></div>
    </div>

    <div id="mobile-controls">
        <div id="joystick-wrapper"><div id="joystick-stick"></div></div>
        <div id="parry-btn">PARRY</div>
    </div>

    <div id="overlay" style="display:none; background: rgba(0,0,0,0.9);">
        <h1 id="end-title" style="font-size: 60px;">DEFEAT</h1>
        <p id="score-text">DEFLECTIONS: 0</p>
        <button id="replay-btn" style="padding: 15px 40px; background: var(--neon-blue); border:none; font-weight: bold; margin-top: 20px;">BACK TO LOBBY</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Core Variables ---
        let scene, camera, renderer, player, ball, bLight;
        let gameActive = false;
        let aliveBots = [];
        let score = 0;
        let ballSpeed = 0.6;
        let currentTargetIndex = -1;
        let currentDir = new THREE.Vector3(0, 0, -1);
        let ballPos = new THREE.Vector3(0, 1.6, 0);
        let canParry = true;
        let isParrying = false;
        let parryTimer = null;
        let startingCount = 8;

        const ARENA_RADIUS = 110;
        const BASE_SPEED = 0.65;
        const SPEED_INC = 0.08;

        // --- Init Scene ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x010105);
            scene.fog = new THREE.FogExp2(0x010105, 0.01);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0x00ffff, 1);
            sun.position.set(10, 50, 10);
            scene.add(sun);

            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 500),
                new THREE.MeshStandardMaterial({ color: 0x050510, roughness: 0.1, metalness: 0.5 })
            );
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            const grid = new THREE.GridHelper(300, 30, 0xff00ff, 0x111122);
            scene.add(grid);

            // Ball
            ball = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 32, 32),
                new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 10 })
            );
            bLight = new THREE.PointLight(0xffffff, 100, 40);
            ball.add(bLight);
            scene.add(ball);

            player = createChar(0x00ffff);
            scene.add(player.group);

            window.addEventListener('resize', onResize);
            setupInput();
            requestAnimationFrame(animate);
        }

        function createChar(color) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.6, 1.2, 4, 12), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            body.position.y = 1.2;
            group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 2 }));
            head.position.y = 2.3;
            group.add(head);

            const swordGrp = new THREE.Group();
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 3.5, 0.15), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: color, emissiveIntensity: 5 }));
            blade.position.y = 1.7;
            swordGrp.add(blade);
            swordGrp.position.set(0.8, 1, 0.5);
            group.add(swordGrp);

            return { group, sword: swordGrp, color, velocity: new THREE.Vector3(), lastPos: new THREE.Vector3() };
        }

        // --- Gameplay Logic ---
        function startGame() {
            aliveBots.forEach(b => scene.remove(b.group));
            aliveBots = [];
            const colors = [0xff00ff, 0x00ffff, 0xffff00, 0x00ff00, 0xff0000, 0x0000ff, 0x00ffaa, 0xffaa00];
            const botCount = startingCount - 1;
            
            for(let i=0; i<botCount; i++) {
                const b = createChar(colors[i % colors.length]);
                const ang = (i/botCount) * Math.PI * 2;
                b.group.position.set(Math.cos(ang)*45, 0, Math.sin(ang)*45);
                scene.add(b.group);
                aliveBots.push(b);
            }
            
            player.group.position.set(0,0,25);
            ballPos.set(0, 1.6, 0);
            ballSpeed = BASE_SPEED;
            currentTargetIndex = -1;
            score = 0;
            gameActive = true;
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('game-ui').style.display = 'flex';
            document.getElementById('mobile-controls').style.display = 'flex';
            document.getElementById('status').innerText = "ELIMINATION START";
        }

        function performParry() {
            if(!canParry || !gameActive) return;
            isParrying = true; canParry = false;
            player.sword.rotation.z = 1.5;
            document.getElementById('parry-bar').style.width = '0%';

            if(parryTimer) clearTimeout(parryTimer);
            parryTimer = setTimeout(() => {
                isParrying = false;
                player.sword.rotation.z = 0;
                setTimeout(() => { 
                    if(!canParry) { 
                        canParry = true; 
                        document.getElementById('parry-bar').style.width = '100%'; 
                    }
                }, 400);
            }, 200);
        }

        function resetParryQuick() {
            isParrying = false;
            player.sword.rotation.z = 0;
            if(parryTimer) clearTimeout(parryTimer);
            const bar = document.getElementById('parry-bar');
            bar.classList.add('resetting');
            bar.style.width = '100%';
            setTimeout(() => {
                canParry = true;
                bar.classList.remove('resetting');
            }, 30);
        }

        // --- Input Handling ---
        let moveX = 0, moveZ = 0, camYaw = 0;
        let joyTouchId = null;
        let camTouchId = null;
        let lastCamX = 0;

        function setupInput() {
            const parryBtn = document.getElementById('parry-btn');
            const joyWrap = document.getElementById('joystick-wrapper');
            const joyStick = document.getElementById('joystick-stick');
            
            parryBtn.addEventListener('touchstart', (e) => { e.preventDefault(); performParry(); });

            window.addEventListener('touchstart', (e) => {
                for(let t of e.changedTouches) {
                    // Check if touching joystick area
                    const rect = joyWrap.getBoundingClientRect();
                    const inJoy = t.clientX >= rect.left && t.clientX <= rect.right && t.clientY >= rect.top && t.clientY <= rect.bottom;
                    
                    if(inJoy && joyTouchId === null) {
                        joyTouchId = t.identifier;
                    } else if (camTouchId === null) {
                        // Any other touch is camera control
                        camTouchId = t.identifier;
                        lastCamX = t.clientX;
                    }
                }
            }, {passive: false});

            window.addEventListener('touchmove', (e) => {
                for(let t of e.changedTouches) {
                    if(t.identifier === joyTouchId) {
                        const rect = joyWrap.getBoundingClientRect();
                        const dx = t.clientX - (rect.left + rect.width/2);
                        const dy = t.clientY - (rect.top + rect.height/2);
                        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), rect.width/2);
                        const angle = Math.atan2(dy, dx);
                        joyStick.style.left = `calc(50% + ${Math.cos(angle)*dist}px)`;
                        joyStick.style.top = `calc(50% + ${Math.sin(angle)*dist}px)`;
                        moveX = (Math.cos(angle)*dist)/(rect.width/2);
                        moveZ = (Math.sin(angle)*dist)/(rect.width/2);
                    } else if (t.identifier === camTouchId) {
                        const deltaX = t.clientX - lastCamX;
                        camYaw -= deltaX * 0.007; // Sensivity
                        lastCamX = t.clientX;
                    }
                }
            }, {passive: false});

            window.addEventListener('touchend', (e) => {
                for(let t of e.changedTouches) {
                    if(t.identifier === joyTouchId) {
                        joyTouchId = null;
                        moveX = 0; moveZ = 0;
                        joyStick.style.left = '50%'; joyStick.style.top = '50%';
                    } else if (t.identifier === camTouchId) {
                        camTouchId = null;
                    }
                }
            });
            
            window.addEventListener('touchcancel', (e) => {
                for(let t of e.changedTouches) {
                    if(t.identifier === joyTouchId) {
                        joyTouchId = null;
                        moveX = 0; moveZ = 0;
                        joyStick.style.left = '50%'; joyStick.style.top = '50%';
                    } else if (t.identifier === camTouchId) {
                        camTouchId = null;
                    }
                }
            });
        }

        function animate(time) {
            requestAnimationFrame(animate);
            if(!gameActive) return;

            // Player movement
            player.lastPos.copy(player.group.position);
            const moveVec = new THREE.Vector3(moveX, 0, moveZ).applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);
            player.group.position.add(moveVec.multiplyScalar(0.5));
            if(player.group.position.length() > ARENA_RADIUS) player.group.position.setLength(ARENA_RADIUS);
            player.velocity.subVectors(player.group.position, player.lastPos);
            if(moveVec.length() > 0.1) player.group.rotation.y = Math.atan2(moveVec.x, moveVec.z);

            // Ball Logic
            const target = (currentTargetIndex === -1) ? player.group : (aliveBots[currentTargetIndex]?.group || player.group);
            const toTarget = new THREE.Vector3().subVectors(target.position, ballPos).normalize();
            currentDir.lerp(toTarget, 0.1).normalize();
            ballPos.add(currentDir.clone().multiplyScalar(ballSpeed));
            ball.position.copy(ballPos);
            ball.position.y = 1.6 + Math.sin(time*0.005)*0.3;

            // Interaction
            const dist = ball.position.distanceTo(target.position);
            if(dist < 7) {
                if(currentTargetIndex === -1) {
                    if(isParrying) {
                        ballSpeed += SPEED_INC;
                        score++;
                        if(aliveBots.length > 0) {
                            currentTargetIndex = Math.floor(Math.random()*aliveBots.length);
                        }
                        resetParryQuick();
                        document.getElementById('status').innerText = "DEFLECTED!";
                    } else if(dist < 2.5) {
                        gameOver(false);
                    }
                } else {
                    const bot = aliveBots[currentTargetIndex];
                    if(bot && dist < Math.max(6, ballSpeed*5)) {
                        const difficulty = Math.min(0.95, 0.8 + (ballSpeed * 0.05));
                        if(Math.random() < difficulty) { 
                            if(aliveBots.length > 1 && Math.random() < 0.3) {
                                let next;
                                do { next = Math.floor(Math.random() * aliveBots.length); } while (next === currentTargetIndex);
                                currentTargetIndex = next;
                            } else {
                                currentTargetIndex = -1;
                            }
                            ballSpeed += SPEED_INC;
                            document.getElementById('status').innerText = "BOT DEFLECTED";
                        } else if(dist < 2.5) {
                            scene.remove(bot.group);
                            aliveBots.splice(currentTargetIndex, 1);
                            currentTargetIndex = -1;
                            if(aliveBots.length === 0) gameOver(true);
                            else document.getElementById('status').innerText = "BOT ELIMINATED";
                        }
                    } else if (!bot) {
                        currentTargetIndex = -1;
                    }
                }
            }

            // Visuals
            const danger = (currentTargetIndex === -1 && dist < 30);
            ball.material.emissive.set(danger ? 0xff0000 : 0x00ffff);
            bLight.color.set(danger ? 0xff0000 : 0x00ffff);

            // Cam
            camera.position.set(
                player.group.position.x + Math.sin(camYaw)*30,
                player.group.position.y + 15,
                player.group.position.z + Math.cos(camYaw)*30
            );
            camera.lookAt(player.group.position);

            renderer.render(scene, camera);
        }

        function gameOver(win) {
            gameActive = false;
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('end-title').innerText = win ? "VICTORY" : "ELIMINATED";
            document.getElementById('score-text').innerText = "DEFLECTIONS: " + score;
            document.getElementById('mobile-controls').style.display = 'none';
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        document.getElementById('start-game-btn').onclick = startGame;
        document.getElementById('replay-btn').onclick = () => {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('lobby').style.display = 'flex';
        };
        
        document.querySelectorAll('.btn-count').forEach(b => {
            b.onclick = () => {
                document.querySelectorAll('.btn-count').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                startingCount = parseInt(b.dataset.count);
            };
        });

        init();
    </script>
</body>
</html>